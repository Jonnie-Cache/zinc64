/*
 * Copyright (c) 2016-2017 Sebastian Jastrzebski. All rights reserved.
 *
 * This file is part of zinc64.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

use std::result::Result;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

use sdl2;
use sdl2::{EventPump, Sdl};
use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};
use sdl2::event::Event;
use sdl2::joystick::Joystick;
use sdl2::keyboard;
use sdl2::keyboard::{Keycode, Mod};
use sdl2::pixels::PixelFormatEnum;
use sdl2::render::{Canvas, Texture, TextureCreator};
use sdl2::video::{FullscreenType, Window};
use time;

use zinc64::device::joystick::Button;
use zinc64::device::keyboard::{Key, KeyEvent};
use zinc64::sound::SoundBuffer;
use zinc64::system::C64;
use zinc64::video::vic;

pub enum JamAction {
    Continue,
    Quit,
    Reset,
}

impl JamAction {
    pub fn from(action: &str) -> JamAction {
        match action {
            "continue" => JamAction::Continue,
            "quit" => JamAction::Quit,
            "reset" => JamAction::Reset,
            _ => panic!("invalid jam action {}", action),
        }
    }
}

#[derive(Debug, PartialEq)]
enum State {
    Running,
    Paused,
    Stopped,
}

pub struct Options {
    pub fullscreen: bool,
    pub jam_action: JamAction,
    pub height: u32,
    pub width: u32,
}

struct AppAudio {
    buffer: Arc<Mutex<SoundBuffer>>,
}

impl AudioCallback for AppAudio {
    type Channel = f32;

    fn callback(&mut self, out: &mut [f32]) {
        let mut input = self.buffer.lock().unwrap();
        for x in out.iter_mut() {
            let sample = input.pop();
            *x = sample as f32 * 0.000020; // FIXME magic value
        }
    }
}

// TODO ui/audio: play/resume/volume

pub struct AppWindow {
    // Dependencies
    c64: C64,
    // Audio
    audio_device: AudioDevice<AppAudio>,
    // Video
    sdl: Sdl,
    canvas: Canvas<Window>,
    // Devices
    joystick1: Option<Joystick>,
    joystick2: Option<Joystick>,
    // Configuration
    jam_action: JamAction,
    // Runtime State
    state: State,
    last_frame_ts: u64,
    next_keyboard_event: u32,
}

impl AppWindow {
    pub fn new(c64: C64, options: Options) -> Result<AppWindow, String> {
        let sdl = sdl2::init()?;
        // Initialize video
        info!(target: "ui", "Opening app window {}x{}", options.width, options.height);
        let video = sdl.video()?;
        let mut builder = video.window("zinc64", options.width, options.height);
        builder.position_centered();
        builder.resizable();
        builder.opengl();
        if options.fullscreen {
            builder.fullscreen();
        }
        let window = builder.build().unwrap();
        let canvas = window.into_canvas().build().unwrap();
        // Initialize audio
        let audio = sdl.audio()?;
        let audio_spec = AudioSpecDesired {
            freq: Some(c64.get_config().sound.sample_rate as i32),
            channels: Some(1),
            samples: Some(c64.get_config().sound.buffer_size as u16),
        };
        let audio_device = audio.open_playback(None, &audio_spec, |spec| {
            info!(target: "audio", "{:?}", spec);
            AppAudio {
                buffer: c64.get_sound_buffer(),
            }
        })?;
        // Initialize devices
        let joystick_subsystem = sdl.joystick()?;
        joystick_subsystem.set_event_state(true);
        let joystick1 = c64.get_joystick1().and_then(|joystick| {
            if !joystick.borrow().is_virtual() {
                info!(target: "ui", "Opening joystick {}", joystick.borrow().get_index());
                joystick_subsystem
                    .open(joystick.borrow().get_index() as u32)
                    .ok()
            } else {
                None
            }
        });
        let joystick2 = c64.get_joystick2().and_then(|joystick| {
            if !joystick.borrow().is_virtual() {
                info!(target: "ui", "Opening joystick {}", joystick.borrow().get_index());
                joystick_subsystem
                    .open(joystick.borrow().get_index() as u32)
                    .ok()
            } else {
                None
            }
        });
        Ok(AppWindow {
            c64: c64,
            sdl: sdl,
            audio_device: audio_device,
            canvas: canvas,
            joystick1: joystick1,
            joystick2: joystick2,
            jam_action: options.jam_action,
            state: State::Running,
            last_frame_ts: 0,
            next_keyboard_event: 0,
        })
    }

    pub fn run(&mut self) -> Result<(), String> {
        info!(target: "ui", "Running main loop");
        self.audio_device.resume();
        let vic_spec = vic::Spec::new(self.c64.get_config().model.vic_model);
        let screen_size = vic_spec.display_rect.size();
        let texture_creator: TextureCreator<_> = self.canvas.texture_creator();
        let mut texture = texture_creator
            .create_texture_streaming(
                PixelFormatEnum::ARGB8888,
                screen_size.width as u32,
                screen_size.height as u32,
            )
            .unwrap();
        let mut events = self.sdl.event_pump().unwrap();
        let mut overflow_cycles = 0i32;
        'running: loop {
            match self.state {
                State::Running => {
                    self.handle_events(&mut events);
                    overflow_cycles = self.c64.run_frame(overflow_cycles);
                    if self.c64.is_cpu_jam() {
                        self.handle_cpu_jam();
                    }
                    let rt = self.c64.get_render_target();
                    if rt.borrow().get_sync() {
                        self.render(&mut texture)?;
                    }
                }
                State::Paused => {
                    self.handle_events(&mut events);
                    let wait = Duration::from_millis(20);
                    thread::sleep(wait);
                }
                State::Stopped => {
                    info!(target: "ui", "State {:?}", self.state);
                    break 'running;
                }
            }
        }
        Ok(())
    }

    fn handle_cpu_jam(&mut self) -> bool {
        let cpu = self.c64.get_cpu();
        match self.jam_action {
            JamAction::Continue => true,
            JamAction::Quit => {
                warn!(target: "ui", "CPU JAM detected at 0x{:x}", cpu.borrow().get_pc());
                self.state = State::Stopped;
                false
            }
            JamAction::Reset => {
                warn!(target: "ui", "CPU JAM detected at 0x{:x}", cpu.borrow().get_pc());
                self.reset();
                false
            }
        }
    }

    fn render(&mut self, texture: &mut Texture) -> Result<(), String> {
        let rt = self.c64.get_render_target();
        texture
            .update(None, rt.borrow().get_pixel_data(), rt.borrow().get_pitch())
            .map_err(|_| "failed to update texture")?;
        self.canvas.clear();
        self.canvas.copy(texture, None, None)?;
        self.canvas.present();
        rt.borrow_mut().set_sync(false);
        self.last_frame_ts = time::precise_time_ns();
        Ok(())
    }

    fn reset(&mut self) {
        self.c64.reset(false);
        self.next_keyboard_event = 0;
    }

    fn toggle_datassette_play(&mut self) {
        let datassette = self.c64.get_datasette();
        if !datassette.borrow().is_playing() {
            datassette.borrow_mut().play();
        } else {
            datassette.borrow_mut().stop();
        }
    }

    fn toggle_fullscreen(&mut self) {
        let window = self.canvas.window_mut();
        match window.fullscreen_state() {
            FullscreenType::Off => {
                window.set_fullscreen(FullscreenType::True).unwrap();
            }
            FullscreenType::True => {
                window.set_fullscreen(FullscreenType::Off).unwrap();
            }
            _ => panic!("invalid fullscreen mode"),
        }
    }

    fn toggle_pause(&mut self) {
        match self.state {
            State::Running => self.state = State::Paused,
            State::Paused => self.state = State::Running,
            _ => {}
        }
    }

    fn toggle_warp(&mut self) {
        let warp_mode = self.c64.get_warp_mode();
        self.c64.set_warp_mode(!warp_mode);
    }

    // -- Event Handling

    fn handle_events(&mut self, events: &mut EventPump) {
        for event in events.poll_iter() {
            match event {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::Escape),
                    ..
                } => {
                    self.state = State::Stopped;
                }
                Event::KeyDown {
                    keycode: Some(Keycode::P),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LALTMOD) =>
                {
                    self.toggle_pause();
                }
                Event::KeyDown {
                    keycode: Some(Keycode::Q),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LALTMOD) =>
                {
                    self.state = State::Stopped;
                }
                Event::KeyDown {
                    keycode: Some(Keycode::W),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LALTMOD) =>
                {
                    self.toggle_warp();
                }
                Event::KeyDown {
                    keycode: Some(Keycode::F9),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LALTMOD) =>
                {
                    self.reset();
                }
                Event::KeyDown {
                    keycode: Some(Keycode::F1),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LCTRLMOD) =>
                {
                    self.toggle_datassette_play();
                }
                Event::KeyDown {
                    keycode: Some(Keycode::Return),
                    keymod,
                    repeat: false,
                    ..
                } if keymod.contains(keyboard::LALTMOD) =>
                {
                    self.toggle_fullscreen();
                }
                Event::KeyDown {
                    keycode: Some(key),
                    keymod,
                    ..
                } => {
                    if let Some(key_event) = self.map_key_event(key, keymod) {
                        let keyboard = self.c64.get_keyboard();
                        keyboard.borrow_mut().on_key_down(key_event);
                        if let Some(ref mut joystick) = self.c64.get_joystick1() {
                            if joystick.borrow().is_virtual() {
                                if let Some(joy_button) = self.map_joy_event(key, keymod) {
                                    joystick.borrow_mut().on_key_down(joy_button);
                                }
                            }
                        }
                        if let Some(ref mut joystick) = self.c64.get_joystick2() {
                            if joystick.borrow().is_virtual() {
                                if let Some(joy_button) = self.map_joy_event(key, keymod) {
                                    joystick.borrow_mut().on_key_down(joy_button);
                                }
                            }
                        }
                    }
                }
                Event::KeyUp {
                    keycode: Some(key),
                    keymod,
                    ..
                } => {
                    if let Some(key_event) = self.map_key_event(key, keymod) {
                        let keyboard = self.c64.get_keyboard();
                        keyboard.borrow_mut().on_key_up(key_event);
                        if let Some(ref mut joystick) = self.c64.get_joystick1() {
                            if joystick.borrow().is_virtual() {
                                if let Some(joy_button) = self.map_joy_event(key, keymod) {
                                    joystick.borrow_mut().on_key_up(joy_button);
                                }
                            }
                        }
                        if let Some(ref mut joystick) = self.c64.get_joystick2() {
                            if joystick.borrow().is_virtual() {
                                if let Some(joy_button) = self.map_joy_event(key, keymod) {
                                    joystick.borrow_mut().on_key_up(joy_button);
                                }
                            }
                        }
                    }
                }
                Event::JoyAxisMotion {
                    which,
                    axis_idx,
                    value,
                    ..
                } => {
                    if let Some(ref mut joystick) = self.c64.get_joystick(which as u8) {
                        joystick.borrow_mut().on_axis_motion(axis_idx, value);
                    }
                }
                Event::JoyButtonDown {
                    which, button_idx, ..
                } => {
                    if let Some(ref mut joystick) = self.c64.get_joystick(which as u8) {
                        joystick.borrow_mut().on_button_down(button_idx);
                    }
                }
                Event::JoyButtonUp {
                    which, button_idx, ..
                } => {
                    if let Some(ref mut joystick) = self.c64.get_joystick(which as u8) {
                        joystick.borrow_mut().on_button_up(button_idx);
                    }
                }
                _ => {}
            }
        }
        let keyboard = self.c64.get_keyboard();
        if keyboard.borrow().has_events() && self.c64.get_cycles() >= self.next_keyboard_event {
            keyboard.borrow_mut().drain_event();
            self.next_keyboard_event = self.c64.get_cycles().wrapping_add(20000);
        }
    }

    fn map_joy_event(&self, keycode: Keycode, _keymod: Mod) -> Option<Button> {
        match keycode {
            Keycode::Kp2 => Some(Button::Down),
            Keycode::Kp4 => Some(Button::Left),
            Keycode::Kp6 => Some(Button::Right),
            Keycode::Kp8 => Some(Button::Up),
            Keycode::KpEnter => Some(Button::Fire),
            _ => None,
        }
    }

    fn map_key_event(&self, keycode: Keycode, keymod: Mod) -> Option<KeyEvent> {
        match keycode {
            // Numerical
            Keycode::Num0
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::new(Key::Num9))
            }
            Keycode::Num0 => Some(KeyEvent::new(Key::Num0)),
            Keycode::Num1 => Some(KeyEvent::new(Key::Num1)),
            Keycode::Num2
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::with_disabled_shift(Key::At))
            }
            Keycode::Num2 => Some(KeyEvent::new(Key::Num2)),
            Keycode::Num3 => Some(KeyEvent::new(Key::Num3)),
            Keycode::Num4 => Some(KeyEvent::new(Key::Num4)),
            Keycode::Num5 => Some(KeyEvent::new(Key::Num5)),
            Keycode::Num6
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::new(Key::Num7))
            }
            Keycode::Num6 => Some(KeyEvent::new(Key::Num6)),
            Keycode::Num7
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::new(Key::Num6))
            }
            Keycode::Num7 => Some(KeyEvent::new(Key::Num7)),
            Keycode::Num8
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::with_disabled_shift(Key::Asterisk))
            }
            Keycode::Num8 => Some(KeyEvent::new(Key::Num8)),
            Keycode::Num9
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::new(Key::Num8))
            }
            Keycode::Num9 => Some(KeyEvent::new(Key::Num9)),
            // Alpha
            Keycode::A => Some(KeyEvent::new(Key::A)),
            Keycode::B => Some(KeyEvent::new(Key::B)),
            Keycode::C => Some(KeyEvent::new(Key::C)),
            Keycode::D => Some(KeyEvent::new(Key::D)),
            Keycode::E => Some(KeyEvent::new(Key::E)),
            Keycode::F => Some(KeyEvent::new(Key::F)),
            Keycode::G => Some(KeyEvent::new(Key::G)),
            Keycode::H => Some(KeyEvent::new(Key::H)),
            Keycode::I => Some(KeyEvent::new(Key::I)),
            Keycode::J => Some(KeyEvent::new(Key::J)),
            Keycode::K => Some(KeyEvent::new(Key::K)),
            Keycode::L => Some(KeyEvent::new(Key::L)),
            Keycode::M => Some(KeyEvent::new(Key::M)),
            Keycode::N => Some(KeyEvent::new(Key::N)),
            Keycode::O => Some(KeyEvent::new(Key::O)),
            Keycode::P => Some(KeyEvent::new(Key::P)),
            Keycode::Q => Some(KeyEvent::new(Key::Q)),
            Keycode::R => Some(KeyEvent::new(Key::R)),
            Keycode::S => Some(KeyEvent::new(Key::S)),
            Keycode::T => Some(KeyEvent::new(Key::T)),
            Keycode::U => Some(KeyEvent::new(Key::U)),
            Keycode::V => Some(KeyEvent::new(Key::V)),
            Keycode::W => Some(KeyEvent::new(Key::W)),
            Keycode::X => Some(KeyEvent::new(Key::X)),
            Keycode::Y => Some(KeyEvent::new(Key::Y)),
            Keycode::Z => Some(KeyEvent::new(Key::Z)),
            //
            Keycode::Asterisk => Some(KeyEvent::new(Key::Asterisk)),
            Keycode::At => Some(KeyEvent::new(Key::At)),
            Keycode::Backslash
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::with_mod(Key::Minus, Key::LShift))
            }
            Keycode::Backspace => Some(KeyEvent::new(Key::Backspace)),
            Keycode::Caret => Some(KeyEvent::new(Key::Caret)),
            Keycode::Colon => Some(KeyEvent::new(Key::Colon)),
            Keycode::Comma => Some(KeyEvent::new(Key::Comma)),
            Keycode::Dollar => Some(KeyEvent::new(Key::Dollar)),
            Keycode::Equals
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::with_disabled_shift(Key::Plus))
            }
            Keycode::Equals => Some(KeyEvent::new(Key::Equals)),
            Keycode::LeftBracket => Some(KeyEvent::with_mod(Key::Colon, Key::LShift)),
            Keycode::Minus => Some(KeyEvent::new(Key::Minus)),
            Keycode::Period => Some(KeyEvent::new(Key::Period)),
            Keycode::Plus => Some(KeyEvent::new(Key::Plus)),
            Keycode::Quote
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::new(Key::Num2))
            }
            Keycode::Quote => Some(KeyEvent::with_mod(Key::Num7, Key::LShift)),
            Keycode::Return => Some(KeyEvent::new(Key::Return)),
            Keycode::RightBracket => Some(KeyEvent::with_mod(Key::Semicolon, Key::LShift)),
            Keycode::Semicolon
                if keymod.contains(keyboard::LSHIFTMOD) || keymod.contains(keyboard::RSHIFTMOD) =>
            {
                Some(KeyEvent::with_disabled_shift(Key::Colon))
            }
            Keycode::Semicolon => Some(KeyEvent::new(Key::Semicolon)),
            Keycode::Slash => Some(KeyEvent::new(Key::Slash)),
            Keycode::Space => Some(KeyEvent::new(Key::Space)),
            //
            Keycode::Down => Some(KeyEvent::new(Key::CrsrDown)),
            Keycode::Home => Some(KeyEvent::new(Key::Home)),
            Keycode::LCtrl => Some(KeyEvent::new(Key::Ctrl)),
            Keycode::Left => Some(KeyEvent::with_mod(Key::CrsrRight, Key::LShift)),
            Keycode::LGui => Some(KeyEvent::new(Key::LGui)),
            Keycode::LShift => Some(KeyEvent::new(Key::LShift)),
            Keycode::Pause => Some(KeyEvent::new(Key::Pause)),
            Keycode::RCtrl => Some(KeyEvent::new(Key::Ctrl)),
            Keycode::Right => Some(KeyEvent::new(Key::CrsrRight)),
            Keycode::RShift => Some(KeyEvent::new(Key::RShift)),
            Keycode::Up => Some(KeyEvent::with_mod(Key::CrsrDown, Key::LShift)),
            // Function
            Keycode::F1 => Some(KeyEvent::new(Key::F1)),
            Keycode::F3 => Some(KeyEvent::new(Key::F3)),
            Keycode::F5 => Some(KeyEvent::new(Key::F5)),
            Keycode::F7 => Some(KeyEvent::new(Key::F7)),
            _ => None,
        }
    }
}


/*
 * Copyright (c) 2016-2017 Sebastian Jastrzebski. All rights reserved.
 *
 * This file is part of zinc64.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

use std::sync::{Arc, Mutex};

use resid;
use super::resid_c;

use super::SoundBuffer;

pub struct Sid {
    resid: resid::Sid,
    resid_wrapper: *mut resid_c::SID,
    // I/O
    buffer: Arc<Mutex<SoundBuffer>>,
    trap: bool,
    debug_counter: u32,
}

impl Sid {
    pub fn new(buffer: Arc<Mutex<SoundBuffer>>) -> Sid {
        let mut sid = Sid {
            resid: resid::Sid::new(resid::ChipModel::Mos6581),
            resid_wrapper: unsafe { resid_c::sid_new() },
            buffer: buffer,
            trap: false,
            debug_counter: 0
        };
        sid.resid.set_sampling_parameters(resid::SamplingMethod::ResampleFast, 985248, 44100);
        sid
    }

    pub fn reset(&mut self) {
        self.resid.reset();
        unsafe {
            resid_c::sid_reset(self.resid_wrapper)
        }
    }

    pub fn step_delta(&mut self, cycles: u32) {
        self.debug_counter += 1;
        let mut buffer = [0i16; 4096]; // FIXME magic value
        let mut buffer2 = [0i16; 4096]; // FIXME magic value
        let buffer_length = buffer.len();
        let mut samples = 0;
        let mut samples2 = 0;
        let mut delta = cycles;
        let mut delta2 = cycles;
        if self.debug_counter == 333332159 {
            println!("XXX debug start");
            self.dump_state();
            println!("XXX debug loop");
            for i in 0..893 {
                println!("XXX clock start {}", i);
                unsafe {
                    resid_c::sid_clock_delta(self.resid_wrapper, 22);
                }
                self.resid.clock_delta(22);
                if !self.check_state() {
                    self.dump_state();
                    panic!("XXX clock end {}", i)
                }
            }
            self.dump_state();
            println!("XXX debug done");
        }
        while delta > 0 {
            unsafe {
                //let read2 = resid_c::sid_clock_sample(self.resid_wrapper, &mut delta2, buffer2[samples2..].as_mut_ptr(), (buffer_length - samples2) as u32);
                //samples2 += read2 as usize;
                //samples += read2 as usize;
                //delta = delta2;
            }
            let (read, next_delta) = self.resid.sample(delta,
                                                       &mut buffer[samples..],
                                                       buffer_length - samples,
                                                       1);
            samples += read as usize;
            delta = next_delta;
        }
        //println!("AUDIO in cyc {} {} samples {} {}", self.debug_counter, cycles, samples, samples2);
        //let valid = self.check_buffers(&buffer[..], &buffer2[..]);
        //if !valid {
            //println!("XXX BUFFER1");
            //self.dump_buffer(&buffer[..]);
            //println!("XXX BUFFER2");
            //self.dump_buffer(&buffer2[..]);
            //self.dump_state();
            //panic!("done");
        //}
        let mut output = self.buffer.lock().unwrap();
        for i in 0..samples {
            output.push(buffer[i]);
        }
    }

    // -- Device I/O

    pub fn read(&self, reg: u8) -> u8 {
        self.resid.read(reg);
        unsafe {
            resid_c::sid_read(self.resid_wrapper, reg)
        }
    }

    pub fn write(&mut self, reg: u8, value: u8) {
        self.resid.write(reg, value);
        unsafe {
            resid_c::sid_write(self.resid_wrapper, reg, value)
        }
    }

    // -- Debug

    fn check_buffers(&self, buffer: &[i16], buffer2: &[i16]) -> bool {
        let length = buffer.len();
        let mut i = 0;
        while i < length {
            if buffer[i] != buffer2[i] {
                return false;
            }
            i += 1;
        }
        return true;
    }

    fn check_buffer_empty(&self, buffer: &[i16]) -> bool {
        let mut empty = true;
        for sample in buffer {
            if *sample != 0 {
                empty = false;
            }
        }
        empty
    }

    fn check_state(&mut self) -> bool {
        let state = self.resid.read_state();
        let mut state2 = resid_c::SIDState::new();
        unsafe {
            resid_c::sid_dump(self.resid_wrapper, &mut state2);
        }
        for i in 0..3 {
            if !(state.envelope_counter[i] == state2.envelope_counter[i] &&
                state.exponential_counter[i] == state2.exponential_counter[i] as u8 &&
                state.exponential_counter_period[i]== state2.exponential_counter_period[i] as u8 &&
                state.rate_counter[i] == state2.rate_counter[i] &&
                state.rate_counter_period[i] == state2.rate_counter_period[i] &&
                state.hold_zero[i] == state2.hold_zero[i]) {
                return false;
            }
        }
        true
    }

    fn dump_buffer(&self, buffer: &[i16]) {
        let mut counter = 0;
        for sample in buffer {
            if counter == 0 {
                print!("    ");
            }
            print!("{}, ", sample);
            counter += 1;
            if counter == 16 {
                counter = 0;
                println!()
            }
        }
        println!()
    }

    fn dump_state(&mut self) {
        let state = self.resid.read_state();
        let mut state2 = resid_c::SIDState::new();
        unsafe {
            resid_c::sid_dump(self.resid_wrapper, &mut state2);
        }
        println!("{:?}", state);
        println!("{:?}", state2);
    }
}









use libc;

pub enum SID {}

#[repr(C)]
#[derive(Debug)]
pub struct SIDState {
    pub sid_register: [u8; 32],
    pub bus_value: u8,
    pub bus_value_ttl: u32,
    pub accumulator: [u32; 3],
    pub shift_register: [u32; 3],
    pub rate_counter: [u16; 3],
    pub rate_counter_period: [u16; 3],
    pub exponential_counter: [u16; 3],
    pub exponential_counter_period: [u16; 3],
    pub envelope_counter: [u8; 3],
    pub hold_zero: [u8; 3],
    pub ext_in: i32,
    pub fc: u16,
    pub res: u8,
    pub filt: u8,
    pub voice3off: u8,
    pub hp_bp_lp: u8,
    pub vol: u8,
    pub mixer_dc: i32,
    pub vhp: i32,
    pub vbp: i32,
    pub vlp: i32,
    pub vnf: i32,
    pub w0: i32,
    pub w0_ceil_1: i32,
    pub w0_ceil_dt: i32,
    pub c_1024_div_q: i32,
}

impl SIDState {
    pub fn new() -> SIDState {
        SIDState {
            sid_register: [0; 32],
            bus_value: 0,
            bus_value_ttl: 0,
            accumulator: [0; 3],
            shift_register: [0; 3],
            rate_counter: [0; 3],
            rate_counter_period: [0; 3],
            exponential_counter: [0; 3],
            exponential_counter_period: [0; 3],
            envelope_counter: [0; 3],
            hold_zero: [0; 3],
            ext_in: 0,
            fc: 0,
            res: 0,
            filt: 0,
            voice3off: 0,
            hp_bp_lp: 0,
            vol: 0,
            mixer_dc: 0,
            vhp: 0,
            vbp: 0,
            vlp: 0,
            vnf: 0,
            w0: 0,
            w0_ceil_1: 0,
            w0_ceil_dt: 0,
            c_1024_div_q: 0,
        }
    }
}
#[link(name = "resid")]
extern "C" {
    pub fn sid_new() -> *mut SID;
    pub fn sid_free(sid: *mut SID);
    pub fn sid_reset(sid: *mut SID);
    pub fn sid_clock(sid: *mut SID);
    pub fn sid_clock_delta(sid: *mut SID, delta: libc::uint32_t);
    pub fn sid_enable_debug(sid: *mut SID, enable: libc::int8_t);
    pub fn sid_output(sid: *mut SID) -> libc::int32_t;
    pub fn sid_read(sid: *mut SID, offset: libc::uint8_t) -> libc::uint8_t;
    pub fn sid_write(sid: *mut SID, offset: libc::uint8_t, value: libc::uint8_t);
    pub fn sid_clock_sample(sid: *mut SID, delta: *mut libc::uint32_t, buf: *mut libc::int16_t, n: libc::uint32_t) -> libc::uint32_t;
    pub fn sid_dump(sid: *mut SID, state: *mut SIDState);
}



- https://forums.libsdl.org/viewtopic.php?t=6723&sid=23faf65c9e5db23708d5a1f7990165c3

https://www.youtube.com/watch?v=DNjkQIjKll4

//http://www.youtube.com/user/thecplusplusguy
//Thanks for the typed in code to Tapit85
#include <SDL/SDL.h>
#include <iostream>
#include <SDL/SDL_ttf.h>
#include <SDL/SDL_mixer.h>
#include "ball.h"
#include "paddle.h"

int showmenu(SDL_Surface* screen, TTF_Font* font)
{
  Uint32 time;
  int x, y;
  const int NUMMENU = 2;
  const char* labels[NUMMENU] = {"Continue","Exit"};
  SDL_Surface* menus[NUMMENU];
  bool selected[NUMMENU] = {0,0};
  SDL_Color color[2] = {{255,255,255},{255,0,0}};

  menus[0] = TTF_RenderText_Solid(font,labels[0],color[0]);
  menus[1] = TTF_RenderText_Solid(font,labels[1],color[0]);
  SDL_Rect pos[NUMMENU];
  pos[0].x = screen->clip_rect.w/2 - menus[0]->clip_rect.w/2;
  pos[0].y = screen->clip_rect.h/2 - menus[0]->clip_rect.h;
  pos[1].x = screen->clip_rect.w/2 - menus[0]->clip_rect.w/2;
  pos[1].y = screen->clip_rect.h/2 + menus[0]->clip_rect.h;

  SDL_FillRect(screen,&screen->clip_rect,SDL_MapRGB(screen->format,0x00,0x00,0x00));

  SDL_Event event;
  while(1)
  {
    time = SDL_GetTicks();
    while(SDL_PollEvent(&event))
    {
      switch(event.type)
      {
        case SDL_QUIT:
          SDL_FreeSurface(menus[0]);
          SDL_FreeSurface(menus[1]);
          return 1;
        case SDL_MOUSEMOTION:
          x = event.motion.x;
          y = event.motion.y;
          for(int i = 0; i < NUMMENU; i += 1) {
            if(x>=pos[i].x && x<=pos[i].x+pos[i].w && y>=pos[i].y && y<=pos[i].y+pos[i].h)
            {
              if(!selected[i])
              {
                selected[i] = 1;
                SDL_FreeSurface(menus[i]);
                menus[i] = TTF_RenderText_Solid(font,labels[i],color[1]);
              }
            }
            else
            {
              if(selected[i])
              {
                selected[i] = 0;
                SDL_FreeSurface(menus[i]);
                menus[i] = TTF_RenderText_Solid(font,labels[i],color[0]);
              }
            }
          }
          break;
        case SDL_MOUSEBUTTONDOWN:
          x = event.button.x;
          y = event.button.y;
          for(int i = 0; i < NUMMENU; i += 1) {
            if(x>=pos[i].x && x<=pos[i].x+pos[i].w && y>=pos[i].y && y<=pos[i].y+pos[i].h)
            {
              SDL_FreeSurface(menus[0]);
              SDL_FreeSurface(menus[1]);
              return i;
            }
          }
          break;
        case SDL_KEYDOWN:
          if(event.key.keysym.sym == SDLK_ESCAPE)
          {
            SDL_FreeSurface(menus[0]);
            SDL_FreeSurface(menus[1]);
            return 0;
          }
      }
    }
    for(int i = 0; i < NUMMENU; i += 1) {
      SDL_BlitSurface(menus[i],NULL,screen,&pos[i]);
    }
    SDL_Flip(screen);
    if(1000/30 > (SDL_GetTicks()-time))
      SDL_Delay(1000/30 - (SDL_GetTicks()-time));
  }
}


SDL_Surface *load_image(const char *c, Uint32 colorkey = 0)
{
  SDL_Surface *tmp = SDL_LoadBMP(c);
  if(colorkey != 0)
  {
    SDL_SetColorKey(tmp, SDL_SRCCOLORKEY, colorkey);
  }
  return tmp;
}

int main()
{
  SDL_Surface *screen, *icon;
  const int width = 640;
  const int height = 480;
  const int FPS = 30;
  screen = SDL_SetVideoMode(width,height,32,SDL_SWSURFACE);
  icon = load_image("icon.bmp");
  SDL_WM_SetIcon(icon, NULL);
  SDL_WM_SetCaption("Pong Game", NULL);
  TTF_Font *font;
  TTF_Init();
  Mix_OpenAudio(22050,MIX_DEFAULT_FORMAT,2,4096);
  Mix_Music *music;
  Mix_Chunk *effect,*effect2;
  music = Mix_LoadMUS("tempmusic.wav");
  effect = Mix_LoadWAV("tempsound1.wav");
  effect2 = Mix_LoadWAV("tempsound2.wav");
  Mix_PlayMusic(music,-1);
  font = TTF_OpenFont("Test.ttf",30);
  SDL_Color color = {0,0,0};
  SDL_Event event;
  Uint32 start;
  bool running = true;
  bool arr[4] = {0,0,0,0};
  paddle player1(load_image("paddle.bmp"),0,225,10,50,3);
  paddle player2(load_image("paddle.bmp"),width-10,255,10,50,3);
  ball ball1(load_image("ball.bmp",SDL_MapRGB(screen->format,0x00,0xff,0xff)),320,240,20,20,3,3);
  int i = showmenu(screen, font);
  if(i==1)
    running = false;
  while(running)
  {
    start = SDL_GetTicks();
    //handle events
    while(SDL_PollEvent(&event))
    {
      switch(event.type)
      {
        case SDL_QUIT:
          running = false;
          break;
        case SDL_KEYDOWN:
          switch(event.key.keysym.sym)
          {
            case SDLK_UP:
              arr[0] = 1;
              break;
            case SDLK_DOWN:
              arr[1] = 1;
              break;

            case SDLK_w:
              arr[2] = 1;
              break;
            case SDLK_s:
              arr[3] = 1;
              break;
            case SDLK_ESCAPE:
              int i = showmenu(screen, font);
              if(i==1)
                running = false;
              break;
          }
          break;
        case SDL_KEYUP:
          switch(event.key.keysym.sym)
          {
            case SDLK_UP:
              arr[0] = 0;
              break;
            case SDLK_DOWN:
              arr[1] = 0;
              break;

            case SDLK_w:
              arr[2] = 0;
              break;
            case SDLK_s:
              arr[3] = 0;
              break;
          }
          break;
      }
    }
    //logic
    if(arr[0])
      player2.moveUp();
    else if(arr[1])
      player2.moveDown();
    if(arr[2])
      player1.moveUp();
    else if(arr[3])
      player1.moveDown();
    ball1.move(player1.getRect(), player2.getRect(), effect);
    switch(ball1.isOut())
    {
      case 1:
        player2.incpoint();
//        player1.setBack(0,225,10,50,3);
//        player2.setBack(width-10,255,10,50,3);
        ball1.setBack(320,240,20,20,3,3,effect2);
        break;
      case 2:
        player1.incpoint();
//        player1.setBack(0,225,10,50,3);
//        player2.setBack(width-10,255,10,50,3);
        ball1.setBack(320,240,20,20,3,3,effect2);
        break;
    }


    //render
    SDL_FillRect(screen, &screen->clip_rect, SDL_MapRGB(screen->format,0xff,0xff,0xff));
    player1.show();
    player2.show();
    ball1.show();

    char c[5];
    SDL_Rect tmp = {10,0};
    sprintf(c, "%d", player1.getPoints());
    SDL_Surface *text = TTF_RenderText_Solid(font,c,color);
    SDL_BlitSurface(text,NULL,screen,&tmp);

    tmp.x = width-40;
    sprintf(c, "%d", player2.getPoints());
    text = TTF_RenderText_Solid(font,c,color);
    SDL_BlitSurface(text,NULL,screen,&tmp);
    SDL_FreeSurface(text);

    SDL_Flip(screen);
    //regulate FPS
    if(1000/FPS > (SDL_GetTicks()-start))
      SDL_Delay(1000/FPS-(SDL_GetTicks()-start));
  }
  // deinitialization
  SDL_FreeSurface(icon);
  Mix_FreeMusic(music);
  Mix_FreeChunk(effect);
  Mix_FreeChunk(effect2);
  Mix_CloseAudio();
  TTF_CloseFont(font);
  TTF_Quit();
  SDL_Quit();
}
